.include "macro-syscalls.m"
    .data
buffer:     .space 2048                      # Буфер для результата: "Min: X Max: Y\0"
temp_buffer:     .space 2048
    .text
    .globl find_min_max_ascii

find_min_max_ascii:
    # Вход: a0 — адрес начала строки
    # Выход: a0 — адрес буфера результата

    # Инициализация
    mv t0, a0                # Сохраняем адрес строки
    lbu t1, (t0)             # Загружаем первый символ (беззнаково)
    beqz t1, return_buffer   # Если строка пуста, завершаем

    mv t2, t1                # Инициализируем минимальный символ
    mv t3, t1                # Инициализируем максимальный символ

loop:
    lbu t1, (t0)             # Загружаем текущий символ (беззнаково)
    beqz t1, done            # Если конец строки (0), завершить цикл

    # Проверяем минимальный символ
    bltu t1, t2, update_min  # Если текущий символ меньше t2, обновляем min
    j check_max              # Иначе проверяем max

update_min:
    mv t2, t1                # Обновляем минимальный символ
    j check_max

check_max:
    bgtu t1, t3, update_max  # Если текущий символ больше t3, обновляем max
    j next_char

update_max:
    mv t3, t1                # Обновляем максимальный символ
    j next_char

next_char:
    addi t0, t0, 1           # Переходим к следующему символу
    j loop

done:
    push(ra)
    mv s1, t3
    # Формируем строку результата: "Min: X (код) Max: Y (код)\0"
    la t0, buffer            # Адрес буфера результата
    
    # Записываем "Min: "
    li t5, 77                # 'M'
    sb t5, 0(t0)
    li t5, 105               # 'i'
    sb t5, 1(t0)
    li t5, 110               # 'n'
    sb t5, 2(t0)
    li t5, 58                # ':'
    sb t5, 3(t0)
    li t5, 32                # ' '
    sb t5, 4(t0)
    
    # Записываем минимальный символ
    mv t5, t2                # Копируем минимальный символ
    sb t5, 5(t0)            # Записываем сам символ
    
    # Записываем " ("
    li t5, 32                # ' '
    sb t5, 6(t0)
    li t5, 40                # '('
    sb t5, 7(t0)
    
    # Записываем код минимального символа
    addi t0, t0, 8          # Смещаем указатель
    mv a1, t2                # Код минимального символа
    mv a0, t0
    jal ra, write_number_to_buffer
    mv t0, a0                # Обновляем указатель буфера

    
    # Записываем ")"
    li t5, 41               # ')'
    sb t5, 0(t0)
    addi t0, t0, 1
    
    # Записываем " Max: "
    li t5, 32               # ' '
    sb t5, 0(t0)
    li t5, 77               # 'M'
    sb t5, 1(t0)
    li t5, 97               # 'a'
    sb t5, 2(t0)
    li t5, 120              # 'x'
    sb t5, 3(t0)
    li t5, 58               # ':'
    sb t5, 4(t0)
    li t5, 32               # ' '
    sb t5, 5(t0)
    
    # Записываем максимальный символ
    mv t5, s1               # Восстанавливаем максимальный символ
    sb t5, 6(t0)
    
    # Записываем " ("
    li t5, 32               # ' '
    sb t5, 7(t0)
    li t5, 40               # '('
    sb t5, 8(t0)
    
    # Записываем код максимального символа
    addi t0, t0, 9          # Смещаем указатель
    mv a0, t0
    mv a1, s1                # Код максимального символа
    jal ra, write_number_to_buffer
    mv t0, a0                # Обновляем указатель буфера

    
    # Записываем ")"
    li t5, 41               # ')'
    sb t5, 0(t0)
    addi t0, t0, 1
    
    # Добавляем нуль-терминатор
    sb zero, 0(t0)
    
    pop(ra)
    j return_buffer

return_buffer:
    mv a1, t0
    la a0, buffer            # Возвращаем адрес буфера результата
    sub a1, a1, a0

    ret                      # Возврат

# Подпрограмма для записи числа в буфер
write_number_to_buffer:
    # Вход: a1 — число для записи
    # Выход: a0 — обновлённый указатель буфера

    # Проверяем, если число 0
    li t5, 0
    beq a1, t5, write_zero

    # Инициализация
    mv t1, a1                # Число для обработки
    li t5, 10                # Основа для деления (десятичная система)
    la t6, temp_buffer       # Временный буфер

write_digit_loop:
    rem s6, t1, t5           # Остаток от деления (последняя цифра числа)
    addi s6, s6, 48          # Преобразуем цифру в ASCII
    sb s6, 0(t6)             # Записываем символ в буфер
    addi t6, t6, 1           # Сдвигаем указатель временного буфера
    div t1, t1, t5           # Делим число на 10
    bnez t1, write_digit_loop
    # Сохраняем начальный адрес буфера
    la t4, temp_buffer       # t4 = начальный адрес temp_buffer

reverse_number:
    addi t6, t6, -1          # Двигаемся назад по буферу
    lb s6, 0(t6)             # Загружаем символ
    sb s6, 0(a0)             # Сохраняем в выходной буфер
    addi a0, a0, 1           # Продвигаем указатель результата
    bgt t6, t4, reverse_number  # Продолжаем если не дошли до начала
    ret

write_zero:
    li t5, 48                # Код ASCII '0'
    sb t5, 0(a0)
    addi a0, a0, 1
    ret
 
    